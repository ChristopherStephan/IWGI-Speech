<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Speech Map</title>
    <!--CartoDB<link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/themes/css/cartodb.css" />-->
	<link rel="stylesheet" href="src/leaflet-0.7/leaflet.css" />
    <link rel="stylesheet" href="src/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="src/bootstrap/font-awesome.css" />
    <link rel="stylesheet" href="src/Minimap/Control.MiniMap.css" />
    <link rel="stylesheet" href="src/geosearch/l.geosearch.css" />
    <link rel="stylesheet" href="src/zoomslider/L.Control.Zoomslider.css" />
    <link rel="stylesheet" href="src/Leaflet.Pancontrol/L.Control.Pan.css" />
    <link rel="stylesheet" href="src/Leaflet.Pancontrol/L.Control.Pan.ie.css" />
    <link rel="stylesheet" href="src/leaflet.locator/L.Control.Locate.css" />
    <link rel="stylesheet" href="src/leaflet.viewcenter/leaflet.viewcenter.css" />
    <link rel="stylesheet" href="src/Leaflet.loading/Control.Loading.css" />
    <link rel="stylesheet" href="src/sidebar/L.Control.Sidebar.css" />
    <link rel="stylesheet" href="src/Leaflet.RevealOSM/Leaflet.RevealOSM.css" />
    <link rel="stylesheet" href="src/Leaflet.EditInOSM/Leaflet.EditInOSM.css" />
    <link rel="stylesheet" href="src/Leaflet.contextmenu/leaflet.contextmenu.css" />
    <link rel="stylesheet" href="src/Leaflet.draw/leaflet.draw.css" />
    <link rel="stylesheet" href="src/Leaflet.MeasureControl/leaflet.measurecontrol.css" />
	<link rel="stylesheet" href="src/custom/custom_css.css"/>

    

    <!--Navigationbar (Bootstrap)-->
    <div id="header">
        <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">IWGI Speech</a>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li>
                            <a href="index.html">Home</a>
                        </li>
                        <li class="active">
                            <a href="SpeechAndLeaflet.html">Map</a>
                        </li>
                        <li>
                            <a href="Help&About.html">Help&amp;About</a>
                        </li>
                        <li></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</head>

<body>  
    <div id="map">
        <div id="vertical"></div>
        <div id="horizontal"></div>
    </div>
    
    <div id="command_animation"></div>
    <div id="sidebar">
        <p>
            <h1>Multimodal GIS</h1>
            <!--Startbutton for Speech-->
            <div id="buttons">
                <h3>Controls:</h3>
                <div id="text" >
                    <button id="start_button" class="btn btn-primary" onclick="startButton(event);" class="btn success">
                        Click to start speaking with the map!
                    </button>
                </div>

                <!--street Layer ON-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOnStreet" class="btn btn-primary" onclick="streetArcGISServer.setMap(map);" class="btn success">
                        Click to turn the Street-Layer On
                    </button>
                </div>

                <!--street Layer OFF-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayeroffStreet" class="btn btn-primary" onclick="streetArcGISServer.setMap(null);" class="btn danger">
                        Click to turn the Street-Layer Off
                    </button>
                </div>

                <!--popstructure Layer ON-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOnPopStructure" class="btn btn-primary" onclick="popstructureArcGISServer.setMap(map);" class="btn success">
                        Click to turn the Popstructure-Layer On
                    </button>
                </div>

                <!--popstructure Layer OFF-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOffPopStructure" class="btn btn-primary" onclick="popstructureArcGISServer.setMap(null);" class="btn danger">
                        Click to turn the Popstructure-Layer Off
                    </button>
                </div>
            </div>
        </p>

        <div id="console" style="margin-top: 200px;">
            <h3>Console:</h3>
            <div id="transcript"></div>
            <div id="interim"></div>
        </div>

        <div id="description">
            <p class="description">To test it you need to run the html site within a web server. Browse the site with Chrome. To start interacting with the map by speech, first click the button, allow microphone access from browser and then you can use "zoom out", "zoom in", "up", "down", "left", "right" as commands to control the map's state.
            <br>You can also use "Adding Street Network" and "Removing Street Network" to add and remove the corresponding layer.<b>
			Webpage uses ArcGIS Services. Functionality to use CartoDB Layer is also supported by the LVector library.</p>
        </div>

    </div>

    <div id="text">
        <button id="sidebar_button" onclick="sidebar.toggle();">
            Speech/Layer
        </button>
    </div>


    <script src="src/leaflet-0.7/leaflet.js"></script>
    <script src="src/bootstrap/bootstrap.min.js"></script>
    <script src="src/jquery/jquery-2.0.3.min.js"></script>
    <script src="src/lvector/lvector-custom.js"></script>
    <script src="src/custom/custom_functions.js"></script>
    <!--https://github.com/JasonSanford/leaflet-vector-layers -->
    <script src="src/Minimap/Control.MiniMap.js"></script>
    <!-- https://github.com/Norkart/Leaflet-MiniMap -->
    <script src="src/geosearch/l.control.geosearch.js"></script>
    <!-- https://github.com/smeijer/L.GeoSearch-->
    <script src="src/geosearch/l.geosearch.provider.google.js"></script>
    <!-- https://github.com/smeijer/L.GeoSearch-->
    <script src="src/leaflet.zoomfs/leaflet.zoomfs.js"></script>
    <!-- Fullscreen Button https://github.com/elidupuis/leaflet.zoomfs -->
    <script src="src/zoomslider/L.Control.Zoomslider.js"></script>
    <!-- http://kartena.github.io/Leaflet.zoomslider/ -->
    <script src="src/Leaflet.Pancontrol/L.Control.Pan.js"></script>
    <!-- http://kartena.github.io/Leaflet.Pancontrol/ -->
    <script src="src/leaflet.locator/L.Control.Locate.js"></script>
    <!-- https://github.com/domoritz/leaflet-locatecontrol -->
    <script src="src/leaflet.viewcenter/leaflet.viewcenter.js"></script>
    <!-- https://github.com/pwldp/leaflet.viewcenter -->
    <script src="src/Leaflet.loading/Control.Loading.js"></script>
    <!-- https://github.com/ebrelsford/Leaflet.loading -->
    <script src="src/sidebar/L.Control.Sidebar.js"></script>
    <script src="src/sidebar/jquery-2.0.3.min.js"></script>
    <script src="src/leaflet.providers/leaflet-providers.js"></script>
    <!--https://github.com/leaflet-extras/leaflet-providers -->
    <script src="src/Leaflet.RevealOSM/Leaflet.RevealOSM.js"></script>
    <!--https://github.com/yohanboniface/Leaflet.RevealOSM -->
    <script src="src/Leaflet.EditInOSM/Leaflet.EditInOSM.js"></script>
    <!--https://github.com/yohanboniface/Leaflet.EditInOSM -->
    <script src="src/Leaflet.contextmenu/leaflet.contextmenu.js"></script>
    <!--https://github.com/aratcliffe/Leaflet.contextmenu-->
    <script src="src/Leaflet.draw/leaflet.draw.js"></script>
    <!--https://github.com/Leaflet/Leaflet.draw -->
    <script src="src/Leaflet.MeasureControl/leaflet.measurecontrol.js"></script>
    <!--https://github.com/makinacorpus/Leaflet.MeasureControl-->
	
    <script>
	
		//four functions to handle operations in context menue
        function showCoordinates (e) {
            alert(e.latlng);
		}
		function centerMap (e) {
            map.panTo(e.latlng);
		}

		function zoomIn (e) {
			map.zoomIn();
		}

		function zoomOut (e) {
		    map.zoomOut();
		}
		
		//new map with map options
		var centerPoint = new L.LatLng(51.95442, 7.62709); // initial view point
        var map = L.map('map', {
            center: [51.95442, 7.62709],
            zoom: 13,
            dragging: true,
            touchZoom: true,
            scrollWheelZoom: true,
            doubleClickZoom: true,
            boxZoom: true,
            tap: true,
            tapTolerance: 15,
            trackResize: true,
            worldCopyJump: false,
            closePopupOnClick: true,
            zoomsliderControl: true,
            loadingControl: true,
			panControl: true,
            zoomControl: false, //disable the zoomControl to show only the zoom control, which handles the Fullscreen mode. Otherwise the map would have the ZoomIn and ZoomOut Control twice	
			// measureControl:true,    //Here it's implemented via "L.Control.measureControl().addTo(map);"
			editInOSMControlOptions: {
				editors: ["id"]		//no other editors enabled
				},
			revealOSMControl: true,		//more options here: https://github.com/yohanboniface/Leaflet.RevealOSM
				revealOSMControlOptions: {
					queryTemplate: '[out:json];(node(around:{radius},{lat},{lng})[name];way(around:{radius},{lat},{lng})[name][highway];);out body qt 1;'
				},
			//more options here: https://github.com/aratcliffe/Leaflet.contextmenu
			/*
			contextmenu: true,
				contextmenuWidth: 140,
				contextmenuItems: [{
					text: 'Show coordinates',
					callback: showCoordinates
				}, {
					text: 'Center map here',
					callback: centerMap
				}, '-', {
					text: 'Zoom in',
					icon: 'src/Leaflet.contextmenu/images/zoom-in.png',
					callback: zoomIn
				}, {
					text: 'Zoom out',
					icon: 'src/Leaflet.contextmenu/images/zoom-out.png',
					callback: zoomOut
				}]
			*/	
			});
		

		// Initialize the FeatureGroup to store editable layers for drawing tool
		var drawnItems = new L.FeatureGroup();
		map.addLayer(drawnItems);

		// Initialize the draw control and pass it the FeatureGroup of editable layers
		var drawControl = new L.Control.Draw({
			draw: {
				position: 'topleft',
				polygon: {
					metric: true,
					title: 'Draw a sexy polygon!',
					allowIntersection: true,
					drawError: {
						color: '#b00b00',
						timeout: 1000
					},
					shapeOptions: {
						color: '#bada55'
					},
					showArea: true
				},
				polyline: {
					metric: true
				},
				circle: {
					metric: true,
					shapeOptions: {
						color: '#662d91'
					}
				}
			},
			edit: {
				featureGroup: drawnItems
			}
		});
		map.addControl(drawControl);

		map.on('draw:created', function (e) {
			var type = e.layerType,
				layer = e.layer;

			if (type === 'marker') {
				layer.bindPopup('A popup!');
			}

			drawnItems.addLayer(layer);
		});
			
			
		//new sidebar	
        var sidebar = L.control.sidebar('sidebar', {
            closeButton: true,
            position: 'right'
        });
        map.addControl(sidebar);

		//an example marker, which is able to open the popup
        var marker = L.marker([51.982, 7.597]).addTo(map).on('click', function () {
            sidebar.toggle();
        });

		
		//new Geolocation tool
        var locater = L.control.locate({
            position: 'topright', // set the location of the control
            drawCircle: true, // controls whether a circle is drawn that shows the uncertainty about the location
            follow: true, // follow the location if `watch` and `setView` are set to true in locateOptions
            stopFollowingOnDrag: false, // stop following when the map is dragged if `follow` is set to true
            circleStyle: {}, // change the style of the circle around the user's location
            markerStyle: {},
            followCircleStyle: {}, // set difference for the style of the circle around the user's location while following
            followMarkerStyle: {},
            circlePadding: [0, 0], // padding around accuracy circle, value is passed to setBounds
            metric: true, // use metric or imperial units
            watch: true,
            onLocationError: function (err) {
                alert(err.message)
            }, // define an error callback function
            onLocationOutsideMapBounds: function (context) { // called when outside map boundaries
                alert(context.options.strings.outsideMapBoundsMsg);
            },
            setView: true, // automatically sets the map view to the user's location
            strings: {
                title: "Show me where I am", // title of the locat control
                popup: "You are within {distance} {unit} from this point", // text to appear if user clicks on circle
                outsideMapBoundsMsg: "You seem located outside the boundaries of the map" // default message for onLocationOutsideMapBounds
            }
            //locateOptions: {}  // define location options e.g enableHighAccuracy: true
        }).addTo(map);

		L.Control.measureControl().addTo(map);

        // new Geoseach Bar			
        new L.Control.GeoSearch({
            provider: new L.GeoSearch.Provider.Google(),
			position: 'topcenter',
			showMarker: true
        }).addTo(map);


        // create custom zoom control with fullscreen button
        var zoomFS = new L.Control.ZoomFS({
            position: 'topright'
        }).addTo(map);
         // you can bind to 2 events: enterFullscreen and exitFullscreen
         // note that these events are on the map object, not the zoomfs object...
        map.on('enterFullscreen', function () {
            if (window.console) window.console.log('enterFullscreen');
        });
        map.on('exitFullscreen', function () {
            if (window.console) window.console.log('exitFullscreen');
        });
         // init ViewCenter plugin
        var viewCenter = new L.Control.ViewCenter({
            position: 'topright'
        }).addTo(map);


		//Creating new layers
        var osm = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>'
        }).addTo(map);

        var minimal = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/{styleId}/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',
            styleId: 22677
        })

		var baseLayersown = {
            "Minimal": minimal,
            "OSM": osm
        };
		
		//Nokia, Mapbox and Cloudmate need specific registration data for defined layers. To provide these, you have to edit the leaflet-providers.js source 
		//More information here: https://github.com/leaflet-extras/leaflet-providers
		var baseLayers = {
			'OpenStreetMap German Style': L.tileLayer.provider('OpenStreetMap.DE'),
			'OpenStreetMap Black and White': L.tileLayer.provider('OpenStreetMap.BlackAndWhite'),
			'OpenStreetMap H.O.T.': L.tileLayer.provider('OpenStreetMap.HOT'),
			'Thunderforest OpenCycleMap': L.tileLayer.provider('Thunderforest.OpenCycleMap'),
			'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport'),
			'Thunderforest Landscape': L.tileLayer.provider('Thunderforest.Landscape'),
			'MapQuest OSM': L.tileLayer.provider('MapQuestOpen.OSM'),
			'MapQuest Aerial': L.tileLayer.provider('MapQuestOpen.Aerial'),
			'MapBox Example': L.tileLayer.provider('MapBox.examples.map-zr0njcqy'),
			'Stamen Toner': L.tileLayer.provider('Stamen.Toner'),
			'Stamen Terrain': L.tileLayer.provider('Stamen.Terrain'),
			'Stamen Watercolor': L.tileLayer.provider('Stamen.Watercolor'),
			'Esri WorldStreetMap': L.tileLayer.provider('Esri.WorldStreetMap'),
			'Esri DeLorme': L.tileLayer.provider('Esri.DeLorme'),
			'Esri WorldTopoMap': L.tileLayer.provider('Esri.WorldTopoMap'),
			'Esri WorldImagery': L.tileLayer.provider('Esri.WorldImagery'),
			'Esri WorldTerrain': L.tileLayer.provider('Esri.WorldTerrain'),
			'Esri WorldShadedRelief': L.tileLayer.provider('Esri.WorldShadedRelief'),
			'Esri WorldPhysical': L.tileLayer.provider('Esri.WorldPhysical'),
			'Esri OceanBasemap': L.tileLayer.provider('Esri.OceanBasemap'),
			'Esri NatGeoWorldMap': L.tileLayer.provider('Esri.NatGeoWorldMap'),
			'Esri WorldGrayCanvas': L.tileLayer.provider('Esri.WorldGrayCanvas'),
			'Nokia Normal Day': L.tileLayer.provider('Nokia.normalDay'),
			'Nokia Normal Day Grey': L.tileLayer.provider('Nokia.normalGreyDay'),
			'Nokia Satellite': L.tileLayer.provider('Nokia.satelliteNoLabelsDay'),
			'Nokia Satellite (Labeled)': L.tileLayer.provider('Nokia.satelliteYesLabelsDay'),
			'Nokia Terrain': L.tileLayer.provider('Nokia.terrainDay'),
			'Acetate': L.tileLayer.provider('Acetate')
		};
		
		//new overlay Layers...these layer will be on top of baselayers
		var overlayLayers = {
			'OpenSeaMap': L.tileLayer.provider('OpenSeaMap'),
			'OpenWeatherMap Clouds': L.tileLayer.provider('OpenWeatherMap.Clouds'),
			'OpenWeatherMap CloudsClassic': L.tileLayer.provider('OpenWeatherMap.CloudsClassic'),
			'OpenWeatherMap Precipitation': L.tileLayer.provider('OpenWeatherMap.Precipitation'),
			'OpenWeatherMap PrecipitationClassic': L.tileLayer.provider('OpenWeatherMap.PrecipitationClassic'),
			'OpenWeatherMap Rain': L.tileLayer.provider('OpenWeatherMap.Rain'),
			'OpenWeatherMap RainClassic': L.tileLayer.provider('OpenWeatherMap.RainClassic'),
			'OpenWeatherMap Pressure': L.tileLayer.provider('OpenWeatherMap.Pressure'),
			'OpenWeatherMap PressureContour': L.tileLayer.provider('OpenWeatherMap.PressureContour'),
			'OpenWeatherMap Wind': L.tileLayer.provider('OpenWeatherMap.Wind'),
			'OpenWeatherMap Temperature': L.tileLayer.provider('OpenWeatherMap.Temperature'),
			'OpenWeatherMap Snow': L.tileLayer.provider('OpenWeatherMap.Snow')
		};
		
		

        //new vector layer
         var streetArcGISServer = new lvector.AGS({
            url: "http://giv-buerger1.uni-muenster.de/arcgis/rest/services/eGovernance/basic_muenster_map/MapServer/4",
            fields: "*",
            uniqueField: "OBJECTID",
            esriOptions: true,
            popupTemplate: '<div class="iw-content"><h3>{STRASSE}</h3>PLZ:{PLZ}<br>Length: {LENGTH}m</div>',
            singlePopup: true
        })


		//new vector layer
        //can be controlled by buttons
         var popstructureArcGISServer = new lvector.AGS({
            url: "http://giv-buerger1.uni-muenster.de/arcgis/rest/services/eGovernance/basic_muenster_map/MapServer/7",
            fields: "*",
            uniqueField: "NAME",
            esriOptions: true,
            popupTemplate: '<div class="iw-content"><h3>Population structure in {NAME}</h3>Area:{FLAECHE_QM}m²<br>Overal population structure: {GES_BEV}<br>0-17: {GES_0_17}<br>18-64: {GES_18_64}<br>65-x: {GES_65_} </div>',
            singlePopup: true
        })

        var operationalLayer = {
            "Streets": streetArcGISServer,
            "Population and PLZ": popstructureArcGISServer
        };



        //New minimap
        //Plugin magic goes here! Note that you cannot use the same layer object again, as that will confuse the two map controls
        var overviewMap = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>'
        })
         var miniMap = new L.Control.MiniMap(overviewMap, {
            toggleDisplay: true,
            mapOptions: {
                panControl: false,
                zoomsliderControl: false,
                crs: L.CRS.Simple,
            }
        }).addTo(map);


		//For now we need two L.control.layer elements, because one can only handle two groups
        //Baselayer Controll
        var layerControlBaselayers = L.control.layers(baseLayersown, baseLayers, {
			collapsed: true
		}).addTo(map);

		//OverlayLayers Control 
		var layerControlOverlayLayers = L.control.layers(overlayLayers, operationalLayer, {
			collapsed: true
		}).addTo(map);

		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////Voice Recognition Part//////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        var recognition = new webkitSpeechRecognition();
        var final_transcript = '';
        var interim_transcript = '';
        var language = 'en-GB'; // TODO: fetch language as option value from drop down box
         // en-GB

        recognition.continuous = true; // keep processing input until stopped
        recognition.interimResults = true; // show interim results
        recognition.lang = language; // specify the language

        recognition.onresult = function (event) {
            // Assemble the transcript from the array of results
            for (var i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    final_transcript = event.results[i][0].transcript;
                } else {
                    interim_transcript = event.results[i][0].transcript;
                }
            }

            console.log("interim: " + interim_transcript);
            console.log("final: " + final_transcript);

            // update the web page
            if (final_transcript.length > 0) {
                $('#transcript').html(final_transcript);
            }

            if (interim_transcript.length > 0) {
                $('#interim').html(interim_transcript);
            }

            // handling commands

            if (final_transcript.indexOf("zoom in") >= 0) {
                $("#command_animation").html("zoom in").css({
                    'fontSize': '12pt'
                }).animate({
                        fontSize: '13em'
                    }, 1100,
                    function () {
                        $("#command_animation").html("");
                    });
                map.zoomIn(1);
                console.log("Zoomed in");
                final_transcript = '';
            }

            if (final_transcript.indexOf("zoom out") >= 0) {
                $("#command_animation").html("zoom out").css('fontSize', '13em').animate({
                        fontSize: '12pt'
                    }, 1100,
                    function () {
                        $("#command_animation").html("");
                    });
                map.zoomOut(1);
                console.log("Zoomed out");
                final_transcript = '';
            }

            if (final_transcript.indexOf("left") >= 0) {
                centerPoint.lng -= 0.08;
                $("#command_animation").html("left").css('fontSize', '13em').animate({
                        'left': '-500px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('left', '45%');
                    });
                map.panTo(centerPoint);
                console.log("Panned Left");
                final_transcript = '';
            }

            if (final_transcript.indexOf("right") >= 0) {
                centerPoint.lng += 0.08;
                $("#command_animation").html("right").css({
                    'fontSize': '13em'
                }).animate({
                        'left': '100%'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('left', '45%');
                    });
                map.panTo(centerPoint);
                console.log("Panned right");
                final_transcript = '';
            }

            if (final_transcript.indexOf("up") >= 0) {
                centerPoint.lat += 0.08;
                $("#command_animation").html("up").css('fontSize', '13em').animate({
                        'top': '-250px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('top', '50%');
                    });
                map.panTo(centerPoint);
                console.log("Panned up");
                final_transcript = '';
            }

            if (final_transcript.indexOf("down") >= 0) {
                centerPoint.lat -= 0.08;
                $("#command_animation").html("down").css('fontSize', '13em').animate({
                        'top': '500px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('top', '50%');
                    });
                map.panTo(centerPoint);
                console.log("Panned down");
                final_transcript = '';
            }

            if (final_transcript.indexOf("adding Street Network") >= 0) {
                streetArcGISServer.setMap(map);
                console.log("adding Street Network");
                final_transcript = '';
            }

            if (final_transcript.indexOf("removing Street Network") >= 0) {
                streetArcGISServer.setMap(null);
                console.log("removing Street Network");
                final_transcript = '';
            }

            if (final_transcript.indexOf("point") >= 0) {
                L.marker(map.getCenter()).addTo(map);
                console.log("added marker");
                final_transcript = '';
            }

            if (final_transcript.indexOf("large circle") >= 0) {
                L.circle(map.getCenter(), 400).addTo(map);
                console.log("added large circle");
                final_transcript = '';
            }

            if (final_transcript.indexOf("medium circle") >= 0) {
                L.circle(map.getCenter(), 200).addTo(map);
                console.log("added medium circle");
                final_transcript = '';
            }

            if (final_transcript.indexOf("small circle") >= 0) {
                L.circle(map.getCenter(), 100).addTo(map);
                console.log("added small circle");
                final_transcript = '';
            }

            if (final_transcript.indexOf("large rectangle") >= 0) {
                L.rectangle([[map.getCenter().lat - 0.01, map.getCenter().lng - 0.01],[map.getCenter().lat + 0.01, map.getCenter().lng + 0.01]]).addTo(map);
                console.log("added rectangle");
                final_transcript = '';
            }


            if (final_transcript.indexOf("medium rectangle") >= 0) {
                L.rectangle([[map.getCenter().lat - 0.005, map.getCenter().lng - 0.005],[map.getCenter().lat + 0.005, map.getCenter().lng + 0.005]]).addTo(map);
                console.log("added rectangle");
                final_transcript = '';
            }


            if (final_transcript.indexOf("small rectangle") >= 0) {
                L.rectangle([[map.getCenter().lat - 0.0025, map.getCenter().lng - 0.0025],[map.getCenter().lat + 0.0025, map.getCenter().lng + 0.0025]]).addTo(map);
                console.log("added rectangle");
                final_transcript = '';
            }



           if (final_transcript.indexOf("show me where I am") >= 0) {
                map.locate({setView: true, maxZoom: 16});
                console.log("located user");
                final_transcript = '';
            }           

                    
        }


        function startButton(event) {
            final_transcript = '';
            recognition.start();
        }
    </script>
</body>

</html>
