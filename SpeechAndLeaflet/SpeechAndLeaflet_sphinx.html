<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Speech Map</title>
    <!--CartoDB<link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/themes/css/cartodb.css" />-->
    <link rel="stylesheet" href="src/leaflet-0.7/leaflet.css" />
    <link rel="stylesheet" href="src/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="src/bootstrap/font-awesome.css" />
    <link rel="stylesheet" href="src/Minimap/Control.MiniMap.css" />
    <link rel="stylesheet" href="src/geosearch/l.geosearch.css" />
    <link rel="stylesheet" href="src/zoomslider/L.Control.Zoomslider.css" />
    <link rel="stylesheet" href="src/Leaflet.Pancontrol/L.Control.Pan.css" />
    <link rel="stylesheet" href="src/Leaflet.Pancontrol/L.Control.Pan.ie.css" />
    <link rel="stylesheet" href="src/leaflet.locator/L.Control.Locate.css" />
    <link rel="stylesheet" href="src/leaflet.viewcenter/leaflet.viewcenter.css" />
    <link rel="stylesheet" href="src/Leaflet.loading/Control.Loading.css" />
    <link rel="stylesheet" href="src/sidebar/L.Control.Sidebar.css" />
    <link rel="stylesheet" href="src/Leaflet.RevealOSM/Leaflet.RevealOSM.css" />
    <link rel="stylesheet" href="src/Leaflet.EditInOSM/Leaflet.EditInOSM.css" />
    <link rel="stylesheet" href="src/Leaflet.contextmenu/leaflet.contextmenu.css" />
    <link rel="stylesheet" href="src/Leaflet.draw/leaflet.draw.css" />
    <link rel="stylesheet" href="src/Leaflet.MeasureControl/leaflet.measurecontrol.css" />
	<link rel="stylesheet" href="src/custom/custom_css.css"/>

    

    <!--Navigationbar (Bootstrap)-->
    <div id="header">
        <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">IWGI Speech</a>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li>
                            <a href="index.html">Home</a>
                        </li>
                        <li class="active">
                            <a href="SpeechAndLeaflet.html">Map</a>
                        </li>
                        <li>
                            <a href="Help&About.html">Help&amp;About</a>
                        </li>
                        <li></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</head>

<body>  
    <div id="map">
        <div id="vertical"></div>
        <div id="horizontal"></div>
    </div>
    
  
	
	
    <div id="sidebar">
        <p>
            <h1>Multimodal GIS</h1>
            <!--Startbutton for Speech-->
          
			  <div id="command_animation"></div>
	
	
	 <select id="grammars"></select>
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <span id="recording-indicator" style="border-radius: 10px; -moz-border-radius: 10px; -webkit-border-radius: 10px; width: 20px; height: 20px; background: red;"></span>
    <h2>Recognition Output</h2>
    <div id="output" style="height:150px;overflow:auto;" >
    </div>
    <h2>Status</h2>
    <div id="current-status">Loading page</div>
                <!--street Layer ON-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOnStreet" class="btn btn-primary" onclick="streetArcGISServer.setMap(map);" class="btn success">
                        Click to turn the Street-Layer On
                    </button>
                </div>

                <!--street Layer OFF-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayeroffStreet" class="btn btn-primary" onclick="streetArcGISServer.setMap(null);" class="btn danger">
                        Click to turn the Street-Layer Off
                    </button>
                </div>

                <!--popstructure Layer ON-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOnPopStructure" class="btn btn-primary" onclick="popstructureArcGISServer.setMap(map);" class="btn success">
                        Click to turn the Popstructure-Layer On
                    </button>
                </div>

                <!--popstructure Layer OFF-->
                <div id="text" style="margin-top: 10px;>
                    <button id="LayerOffPopStructure" class="btn btn-primary" onclick="popstructureArcGISServer.setMap(null);" class="btn danger">
                        Click to turn the Popstructure-Layer Off
                    </button>
                </div>
           
        </p>

        <div id="console" style="margin-top: 100px;">
            <h3>Console:</h3>
            <div id="transcript"></div>
            <div id="interim"></div>
        </div>

        <div id="description">
            <p class="description">To test it you need to run the html site within a web server. Browse the site with Chrome. To start interacting with the map by speech, first click the button, allow microphone access from browser and then you can use <br>
			<ul>
			  <li>Zoom inZoom out</li>
			  <li>Up, Down, left, right</li>
			</ul>
			To add layers you can use <br>
			<ul>
			  <li>Adding Street Network</li>
			  <li>removing street Network</li>
			</ul>
            To draw elements like rectangles, circle and point you have so say<br>
			<ul>
			  <li>Small, medium or large rectangle</li>			  
			  <li>Small, medium or large circle</li>
			  <li>Point</li>
			</ul>
			To check, where you are, say <br>
			<ul>
			  <li>Show me where I am</li>			</ul>
			  <br></br>
			</p>
        </div>

    </div>
 </div>
    <div id="text">
        <button id="sidebar_button" onclick="sidebar.toggle();">
            Speech/Layer
        </button>
    </div>

	
    <script src="src/jquery/jquery-2.0.3.min.js"></script>
    <script src="src/leaflet-0.7/leaflet.js"></script>
    <script src="src/bootstrap/bootstrap.min.js"></script>
    <script src="src/lvector/lvector-custom.js"></script>
    <script src="src/custom/custom_functions.js"></script>
    <!--https://github.com/JasonSanford/leaflet-vector-layers -->
    <script src="src/Minimap/Control.MiniMap.js"></script>
    <!-- https://github.com/Norkart/Leaflet-MiniMap -->
    <script src="src/geosearch/l.control.geosearch.js"></script>
    <!-- https://github.com/smeijer/L.GeoSearch-->
    <script src="src/geosearch/l.geosearch.provider.google.js"></script>
    <!-- https://github.com/smeijer/L.GeoSearch-->
    <script src="src/leaflet.zoomfs/leaflet.zoomfs.js"></script>
    <!-- Fullscreen Button https://github.com/elidupuis/leaflet.zoomfs -->
    <script src="src/zoomslider/L.Control.Zoomslider.js"></script>
    <!-- http://kartena.github.io/Leaflet.zoomslider/ -->
    <script src="src/Leaflet.Pancontrol/L.Control.Pan.js"></script>
    <!-- http://kartena.github.io/Leaflet.Pancontrol/ -->
    <script src="src/leaflet.locator/L.Control.Locate.js"></script>
    <!-- https://github.com/domoritz/leaflet-locatecontrol -->
    <script src="src/leaflet.viewcenter/leaflet.viewcenter.js"></script>
    <!-- https://github.com/pwldp/leaflet.viewcenter -->
    <script src="src/Leaflet.loading/Control.Loading.js"></script>
    <!-- https://github.com/ebrelsford/Leaflet.loading -->
    <script src="src/sidebar/L.Control.Sidebar.js"></script>
    <script src="src/sidebar/jquery-2.0.3.min.js"></script>
    <script src="src/leaflet.providers/leaflet-providers.js"></script>
    <!--https://github.com/leaflet-extras/leaflet-providers -->
    <script src="src/Leaflet.RevealOSM/Leaflet.RevealOSM.js"></script>
    <!--https://github.com/yohanboniface/Leaflet.RevealOSM -->
    <script src="src/Leaflet.EditInOSM/Leaflet.EditInOSM.js"></script>
    <!--https://github.com/yohanboniface/Leaflet.EditInOSM -->
    <script src="src/Leaflet.contextmenu/leaflet.contextmenu.js"></script>
    <!--https://github.com/aratcliffe/Leaflet.contextmenu-->
    <script src="src/Leaflet.draw/leaflet.draw.js"></script>
    <!--https://github.com/Leaflet/Leaflet.draw -->
    <script src="src/Leaflet.MeasureControl/leaflet.measurecontrol.js"></script>
    <!--https://github.com/makinacorpus/Leaflet.MeasureControl-->
	
	
	  <!-- These are the two JavaScript files you must load in the HTML,
    The recognizer is loaded through a Web Worker -->
    <script src="js/audioRecorder.js"></script>
    <script src="js/callbackManager.js"></script>
	
    <script>
	
	  /*Adding Words:
	  var recognizer = new Module.Recognizer();
var words = new Module.VectorWords();
words.push_back(["LEFT", "L EH F T"]);

if (recognizer.addWords(words) != Module.ReturnType.SUCCESS)
    // Probably bad format used for pronunciation
    alert("Error while adding words");
words.delete()*/
	
	
	
	
		//four functions to handle operations in context menue
        function showCoordinates (e) {
            alert(e.latlng);
		}
		function centerMap (e) {
            map.panTo(e.latlng);
		}

		function zoomIn (e) {
			map.zoomIn();
		}

		function zoomOut (e) {
		    map.zoomOut();
		}
		
		//Set Focus to Search Box
		function setFocusToTextBox(){
			document.getElementById("leaflet-control-geosearch-qry").focus();
		}
		
		//new map with map options
		var centerPoint = new L.LatLng(51.95442, 7.62709); // initial view point
        var map = L.map('map', {
            center: [51.95442, 7.62709],
            zoom: 13,
            dragging: true,
            touchZoom: true,
            scrollWheelZoom: true,
            doubleClickZoom: true,
            boxZoom: true,
            tap: true,
            tapTolerance: 15,
            trackResize: true,
            worldCopyJump: false,
            closePopupOnClick: true,
            zoomsliderControl: true,
            loadingControl: true,
			panControl: true,
            zoomControl: false, //disable the zoomControl to show only the zoom control, which handles the Fullscreen mode. Otherwise the map would have the ZoomIn and ZoomOut Control twice	
			// measureControl:true,    //Here it's implemented via "L.Control.measureControl().addTo(map);"
			editInOSMControlOptions: {
				editors: ["id"]		//no other editors enabled
				},
			revealOSMControl: true,		//more options here: https://github.com/yohanboniface/Leaflet.RevealOSM
				revealOSMControlOptions: {
					queryTemplate: '[out:json];(node(around:{radius},{lat},{lng})[name];way(around:{radius},{lat},{lng})[name][highway];);out body qt 1;'
				},
			//more options here: https://github.com/aratcliffe/Leaflet.contextmenu
			/*
			contextmenu: true,
				contextmenuWidth: 140,
				contextmenuItems: [{
					text: 'Show coordinates',
					callback: showCoordinates
				}, {
					text: 'Center map here',
					callback: centerMap
				}, '-', {
					text: 'Zoom in',
					icon: 'src/Leaflet.contextmenu/images/zoom-in.png',
					callback: zoomIn
				}, {
					text: 'Zoom out',
					icon: 'src/Leaflet.contextmenu/images/zoom-out.png',
					callback: zoomOut
				}]
			*/	
			});
		

		// Initialize the FeatureGroup to store editable layers for drawing tool
		var drawnItems = new L.FeatureGroup();
		map.addLayer(drawnItems);

		// Initialize the draw control and pass it the FeatureGroup of editable layers
		var drawControl = new L.Control.Draw({
			draw: {
				position: 'topleft',
				polygon: {
					metric: true,
					title: 'Draw a sexy polygon!',
					allowIntersection: true,
					drawError: {
						color: '#b00b00',
						timeout: 1000
					},
					shapeOptions: {
						color: '#bada55'
					},
					showArea: true
				},
				polyline: {
					metric: true
				},
				circle: {
					metric: true,
					shapeOptions: {
						color: '#662d91'
					}
				}
			},
			edit: {
				featureGroup: drawnItems
			}
		});
		map.addControl(drawControl);

		map.on('draw:created', function (e) {
			var type = e.layerType,
				layer = e.layer;

			if (type === 'marker') {
				layer.bindPopup('A popup!');
			}

			drawnItems.addLayer(layer);
		});
			
			
		//new sidebar	
        var sidebar = L.control.sidebar('sidebar', {
            closeButton: true,
            position: 'right'
        });
        map.addControl(sidebar);

		//an example marker, which is able to open the popup
        var marker = L.marker([51.982, 7.597]).addTo(map).on('click', function () {
            sidebar.toggle();
        });

		
		//new Geolocation tool
        var locater = L.control.locate({
            position: 'topright', // set the location of the control
            drawCircle: true, // controls whether a circle is drawn that shows the uncertainty about the location
            follow: true, // follow the location if `watch` and `setView` are set to true in locateOptions
            stopFollowingOnDrag: false, // stop following when the map is dragged if `follow` is set to true
            circleStyle: {}, // change the style of the circle around the user's location
            markerStyle: {},
            followCircleStyle: {}, // set difference for the style of the circle around the user's location while following
            followMarkerStyle: {},
            circlePadding: [0, 0], // padding around accuracy circle, value is passed to setBounds
            metric: true, // use metric or imperial units
            watch: true,
            onLocationError: function (err) {
                alert(err.message)
            }, // define an error callback function
            onLocationOutsideMapBounds: function (context) { // called when outside map boundaries
                alert(context.options.strings.outsideMapBoundsMsg);
            },
            setView: true, // automatically sets the map view to the user's location
            strings: {
                title: "Show me where I am", // title of the locat control
                popup: "You are within {distance} {unit} from this point", // text to appear if user clicks on circle
                outsideMapBoundsMsg: "You seem located outside the boundaries of the map" // default message for onLocationOutsideMapBounds
            }
            //locateOptions: {}  // define location options e.g enableHighAccuracy: true
        }).addTo(map);

		L.Control.measureControl().addTo(map);

        // new Geoseach Bar			
        new L.Control.GeoSearch({
            provider: new L.GeoSearch.Provider.Google(),
			position: 'topcenter',
			showMarker: true
        }).addTo(map);
		
		



        // create custom zoom control with fullscreen button
        var zoomFS = new L.Control.ZoomFS({
            position: 'topright'
        }).addTo(map);
         // you can bind to 2 events: enterFullscreen and exitFullscreen
         // note that these events are on the map object, not the zoomfs object...
        map.on('enterFullscreen', function () {
            if (window.console) window.console.log('enterFullscreen');
        });
        map.on('exitFullscreen', function () {
            if (window.console) window.console.log('exitFullscreen');
        });
         // init ViewCenter plugin
        var viewCenter = new L.Control.ViewCenter({
            position: 'topright'
        }).addTo(map);


		//Creating new layers
        var osm = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>'
        }).addTo(map);

        var minimal = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/{styleId}/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',
            styleId: 22677
        })

		var baseLayersown = {
            "Minimal": minimal,
            "OSM": osm
        };
		
		//Nokia, Mapbox and Cloudmate need specific registration data for defined layers. To provide these, you have to edit the leaflet-providers.js source 
		//More information here: https://github.com/leaflet-extras/leaflet-providers
		var baseLayers = {
			'OpenStreetMap German Style': L.tileLayer.provider('OpenStreetMap.DE'),
			'OpenStreetMap Black and White': L.tileLayer.provider('OpenStreetMap.BlackAndWhite'),
			'OpenStreetMap H.O.T.': L.tileLayer.provider('OpenStreetMap.HOT'),
			'Thunderforest OpenCycleMap': L.tileLayer.provider('Thunderforest.OpenCycleMap'),
			'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport'),
			'Thunderforest Landscape': L.tileLayer.provider('Thunderforest.Landscape'),
			'MapQuest OSM': L.tileLayer.provider('MapQuestOpen.OSM'),
			'MapQuest Aerial': L.tileLayer.provider('MapQuestOpen.Aerial'),
			'MapBox Example': L.tileLayer.provider('MapBox.examples.map-zr0njcqy'),
			'Stamen Toner': L.tileLayer.provider('Stamen.Toner'),
			'Stamen Terrain': L.tileLayer.provider('Stamen.Terrain'),
			'Stamen Watercolor': L.tileLayer.provider('Stamen.Watercolor'),
			'Esri WorldStreetMap': L.tileLayer.provider('Esri.WorldStreetMap'),
			'Esri DeLorme': L.tileLayer.provider('Esri.DeLorme'),
			'Esri WorldTopoMap': L.tileLayer.provider('Esri.WorldTopoMap'),
			'Esri WorldImagery': L.tileLayer.provider('Esri.WorldImagery'),
			'Esri WorldTerrain': L.tileLayer.provider('Esri.WorldTerrain'),
			'Esri WorldShadedRelief': L.tileLayer.provider('Esri.WorldShadedRelief'),
			'Esri WorldPhysical': L.tileLayer.provider('Esri.WorldPhysical'),
			'Esri OceanBasemap': L.tileLayer.provider('Esri.OceanBasemap'),
			'Esri NatGeoWorldMap': L.tileLayer.provider('Esri.NatGeoWorldMap'),
			'Esri WorldGrayCanvas': L.tileLayer.provider('Esri.WorldGrayCanvas'),
			'Nokia Normal Day': L.tileLayer.provider('Nokia.normalDay'),
			'Nokia Normal Day Grey': L.tileLayer.provider('Nokia.normalGreyDay'),
			'Nokia Satellite': L.tileLayer.provider('Nokia.satelliteNoLabelsDay'),
			'Nokia Satellite (Labeled)': L.tileLayer.provider('Nokia.satelliteYesLabelsDay'),
			'Nokia Terrain': L.tileLayer.provider('Nokia.terrainDay'),
			'Acetate': L.tileLayer.provider('Acetate')
		};
		
		//new overlay Layers...these layer will be on top of baselayers
		var overlayLayers = {
			'OpenSeaMap': L.tileLayer.provider('OpenSeaMap'),
			'OpenWeatherMap Clouds': L.tileLayer.provider('OpenWeatherMap.Clouds'),
			'OpenWeatherMap CloudsClassic': L.tileLayer.provider('OpenWeatherMap.CloudsClassic'),
			'OpenWeatherMap Precipitation': L.tileLayer.provider('OpenWeatherMap.Precipitation'),
			'OpenWeatherMap PrecipitationClassic': L.tileLayer.provider('OpenWeatherMap.PrecipitationClassic'),
			'OpenWeatherMap Rain': L.tileLayer.provider('OpenWeatherMap.Rain'),
			'OpenWeatherMap RainClassic': L.tileLayer.provider('OpenWeatherMap.RainClassic'),
			'OpenWeatherMap Pressure': L.tileLayer.provider('OpenWeatherMap.Pressure'),
			'OpenWeatherMap PressureContour': L.tileLayer.provider('OpenWeatherMap.PressureContour'),
			'OpenWeatherMap Wind': L.tileLayer.provider('OpenWeatherMap.Wind'),
			'OpenWeatherMap Temperature': L.tileLayer.provider('OpenWeatherMap.Temperature'),
			'OpenWeatherMap Snow': L.tileLayer.provider('OpenWeatherMap.Snow')
		};
		
		

        //new vector layer
         var streetArcGISServer = new lvector.AGS({
            url: "http://giv-buerger1.uni-muenster.de/arcgis/rest/services/eGovernance/basic_muenster_map/MapServer/4",
            fields: "*",
            uniqueField: "OBJECTID",
            esriOptions: true,
            popupTemplate: '<div class="iw-content"><h3>{STRASSE}</h3>PLZ:{PLZ}<br>Length: {LENGTH}m</div>',
            singlePopup: true
        })


		//new vector layer
        //can be controlled by buttons
         var popstructureArcGISServer = new lvector.AGS({
            url: "http://giv-buerger1.uni-muenster.de/arcgis/rest/services/eGovernance/basic_muenster_map/MapServer/7",
            fields: "*",
            uniqueField: "NAME",
            esriOptions: true,
            popupTemplate: '<div class="iw-content"><h3>Population structure in {NAME}</h3>Area:{FLAECHE_QM}m²<br>Overal population structure: {GES_BEV}<br>0-17: {GES_0_17}<br>18-64: {GES_18_64}<br>65-x: {GES_65_} </div>',
            singlePopup: true
        })

        var operationalLayer = {
            "Streets": streetArcGISServer,
            "Population and PLZ": popstructureArcGISServer
        };



        //New minimap
        //Plugin magic goes here! Note that you cannot use the same layer object again, as that will confuse the two map controls
        var overviewMap = L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>'
        })
         var miniMap = new L.Control.MiniMap(overviewMap, {
            toggleDisplay: true,
            mapOptions: {
                panControl: false,
                zoomsliderControl: false,
                crs: L.CRS.Simple,
            }
        }).addTo(map);


		//For now we need two L.control.layer elements, because one can only handle two groups
        //Baselayer Controll
        var layerControlBaselayers = L.control.layers(baseLayersown, baseLayers, {
			collapsed: true
		}).addTo(map);

		//OverlayLayers Control 
		var layerControlOverlayLayers = L.control.layers(overlayLayers, operationalLayer, {
			collapsed: true
		}).addTo(map);

		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////Voice Recognition Part//////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         // These will be initialized later
      var recognizer, recorder, callbackManager, audioContext, outputContainer;
      // Only when both recorder and recognizer do we have a ready application
      var recorderReady = recognizerReady = false;

      // A convenience function to post a message to the recognizer and associate
      // a callback to its response
      function postRecognizerJob(message, callback) {
        var msg = message || {};
        if (callbackManager) msg.callbackId = callbackManager.add(callback);
        if (recognizer) recognizer.postMessage(msg);
      };

      // This function initializes an instance of the recorder
      // it posts a message right away and calls onReady when it
      // is ready so that onmessage can be properly set
      function spawnWorker(workerURL, onReady) {
          recognizer = new Worker(workerURL);
          recognizer.onmessage = function(event) {
            onReady(recognizer);
          };
          recognizer.postMessage('');
      };

      // To display the hypothesis sent by the recognizer
      function updateHyp(hyp) {
	    //This displays the hyp
        if (outputContainer) outputContainer.innerHTML = hyp;
		
		// This checks the hyp and executes a function according the command
						
			
      };
	  

      // This updates the UI when the app might get ready
      // Only when both recorder and recognizer are ready do we enable the buttons
      function updateUI() {
        if (recorderReady && recognizerReady) startBtn.disabled = stopBtn.disabled = false;
		
		

      };

      // This is just a logging window where we display the status
      function updateStatus(newStatus) {
        document.getElementById('current-status').innerHTML += "<br/>" + newStatus;
      };

      // A not-so-great recording indicator
      function displayRecording(display) {
        if (display) document.getElementById('recording-indicator').innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        else document.getElementById('recording-indicator').innerHTML = "";
      };

      // Callback function once the user authorises access to the microphone
      // in it, we instanciate the recorder
      function startUserMedia(stream) {
        var input = audioContext.createMediaStreamSource(stream);
        var audioRecorderConfig = {errorCallback: function(x) {updateStatus("Error from recorder: " + x);}};
       // Can be configured:
	   // https://github.com/syl22-00/pocketsphinx.js/tree/master/doc/AudioRecorder
		recorder = new AudioRecorder(input, audioRecorderConfig);
        // If a recognizer is ready, we pass it to the recorder
        if (recognizer) recorder.consumers = [recognizer];
        recorderReady = true;
        updateUI();
        updateStatus("Audio recorder ready");
      };

      // This starts recording. We first need to get the id of the grammar to use
      var startRecording = function() {
        var id = document.getElementById('grammars').value;
        if (recorder && recorder.start(id)) displayRecording(true);
      };

      // Stops recording
      var stopRecording = function() {
        recorder && recorder.stop();
        displayRecording(false);
      };

      // Called once the recognizer is ready
      // We then add the grammars to the input select tag and update the UI
      var recognizerReady = function() {
           updateGrammars();
           recognizerReady = true;
           updateUI();
           updateStatus("Recognizer ready");
      };

      // We get the grammars defined below and fill in the input select tag
      var updateGrammars = function() {
        var selectTag = document.getElementById('grammars');
        for (var i = 0 ; i < grammarIds.length ; i++) {
            var newElt = document.createElement('option');
            newElt.value=grammarIds[i].id;
            newElt.innerHTML = grammarIds[i].title;
            selectTag.appendChild(newElt);
        }                          
      };

      // This adds a grammar from the grammars array
      // We add them one by one and call it again as
      // a callback.
      // Once we are done adding all grammars, we can call
      // recognizerReady()
      var feedGrammar = function(g, index, id) {
        if (id && (grammarIds.length > 0)) grammarIds[0].id = id.id;
        if (index < g.length) {
          grammarIds.unshift({title: g[index].title})
	  postRecognizerJob({command: 'addGrammar', data: g[index].g},
                             function(id) {feedGrammar(grammars, index + 1, {id:id});});
        } else {
          recognizerReady();
        }
      };

      // This adds words to the recognizer. When it calls back, we add grammars
      var feedWords = function(words) {
           postRecognizerJob({command: 'addWords', data: words},
                        function() {feedGrammar(grammars, 0);});
      };

      // This initializes the recognizer. When it calls back, we add words
      var initRecognizer = function() {
          // You can pass parameters to the recognizer, such as : {command: 'initialize', data: [["-hmm", "my_model"], ["-fwdflat", "no"]]}
          postRecognizerJob({command: 'initialize'},
                            function() {
                                        if (recorder) recorder.consumers = [recognizer];
                                        feedWords(wordList);});
      };

      // When the page is loaded, we spawn a new recognizer worker and call getUserMedia to
      // request access to the microphone
      window.onload = function() {
        outputContainer = document.getElementById("output");
        updateStatus("Initializing web audio and speech recognizer, waiting for approval to access the microphone");
        callbackManager = new CallbackManager();
        spawnWorker("js/recognizer.js", function(worker) {
            // This is the onmessage function, once the worker is fully loaded
            worker.onmessage = function(e) {
                // This is the case when we have a callback id to be called
                if (e.data.hasOwnProperty('id')) {
                  var clb = callbackManager.get(e.data['id']);
                  var data = {};
                  if ( e.data.hasOwnProperty('data')) data = e.data.data;
                  if(clb) clb(data);
                }
                // This is a case when the recognizer has a new hypothesis
                if (e.data.hasOwnProperty('hyp')) {
                  var newHyp = e.data.hyp;
                  if (e.data.hasOwnProperty('final') &&  e.data.final) newHyp = "Final: " + newHyp;
                  
				 
				  updateHyp(newHyp);
				  checkHyp(newHyp);
				  newHyp="";
				  newHyp="";
				  newHyp="";
				  newHyp="";
                }
				
				
                // This is the case when we have an error
                if (e.data.hasOwnProperty('status') && (e.data.status == "error")) {
                  updateStatus("Error in " + e.data.command + " with code " + e.data.code);
                }
            };
            // Once the worker is fully loaded, we can call the initialize function
            initRecognizer();
        });

        // The following is to initialize Web Audio
        try {
          window.AudioContext = window.AudioContext || window.webkitAudioContext;
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
          window.URL = window.URL || window.webkitURL;
          audioContext = new AudioContext();
        } catch (e) {
          updateStatus("Error initializing Web Audio browser");
        }
        if (navigator.getUserMedia) navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
                                        updateStatus("No live audio input in this browser");
                                    });
        else updateStatus("No web audio support in this browser");

      // Wiring JavaScript to the UI
      var startBtn = document.getElementById('startBtn');
      var stopBtn = document.getElementById('stopBtn');
      startBtn.disabled = true;
      stopBtn.disabled = true;
      startBtn.onclick = startRecording;
      stopBtn.onclick = stopRecording;
      };

	  

	  
	//////////////////////////////////////////////////////////
	/////Grammar and vocabulary //////////////////////////////
	//////////////////////////////////////////////////////////
	  
	  
	  
	  
	  
	  
       // This is the list of words that need to be added to the recognizer
       // This follows the CMU dictionary format
      var wordList = [["LEFT", "L EH F T"], ["RIGHT", "R AY T"], ["UP", "AH P"],["DOWN", "D AW N"],["ZOOM", "Z UW M"],["IN", "IH N"],["OUT", "AW T"],["LOCATE", "L OW K EY T"],["STOP", "S T AA P"],["SHOW", "SH OW"],["INFORMATION", "IH N F AO R M EY SH AH N"],["INFORMATION(2)", "IH N F ER M EY SH AH N"],["HIDE", "HH AY D"],["START", "S T AA R T"],
					  ["MEASUREMENT", "M EH ZH ER M AH N T"],["POINT", "P OY N T"],["CIRCLE", "S ER K AH L"],["RECTANGLE", "R EH K T AE NG G AH L"],["SMALL", "S M AO L"], ["MEDIUM", "M IY D IY AH M"], ["LARGE", "L AA R JH"]];
     
	 //different grammars
      var grammarPAN = {numStates: 1, start: 0, end: 0, transitions: [{from: 0, to: 0, word: "UP"}, {from: 0, to: 0, word: "DOWN"}, {from: 0, to: 0, word: "LEFT"}, {from: 0, to: 0, word: "RIGHT"}]};     
      
	  var grammarZOOM = {numStates: 7, start: 0, end: 6, transitions: [{from: 0, to: 1, word: "ZOOM"}, {from: 1, to: 2, word: "IN"},  {from: 1, to: 2, word: "OUT"}]};
	  var grammarTOOLS = {numStates: 7, start: 0, end: 2, transitions: [{from: 0, to: 1, word: "LOCATE"},{from: 0, to: 1, word: "SHOW"}, {from: 0, to: 1, word: "MEASUREMENT"}, {from: 0, to: 1, word: "HIDE"}, {from: 1, to: 2, word: "STOP"}, {from: 1, to: 2, word: "START"}, {from: 1, to: 2, word: "INFORMATION"}]};
	  var grammarDRAW = {numStates: 6, start: 0, end: 2, transitions: [{from: 0, to: 0, word: "POINT"},{from: 0, to: 1, word: "LARGE"}, {from: 0, to: 1, word: "MEDIUM"}, {from: 0, to: 1, word: "SMALL"}, {from: 1, to: 2, word: "CIRCLE"}, {from: 1, to: 2, word: "RECTANGLE"}]};
	  var grammars = [ {title: "ZOOM", g: grammarZOOM}, {title: "PAN", g: grammarPAN},{title: "TOOLS", g: grammarTOOLS},{title: "DRAW", g: grammarDRAW}];
      var grammarIds = [];
	  
	  
	//////////////////////////////////////////////////////////
	/////Check the Recognition hyp ///////////////////////////
	//////////////////////////////////////////////////////////  


    function checkHyp(hyp) {
	    if(hyp=="LEFT"){
		 				 
	    stopRecording();
		startRecording();
		
		pan_left();	
		
				 
	  }
	   if(hyp=="RIGHT"){
		 				 
	    stopRecording();
		startRecording();
		//document.getElementById("output").innerHTML = "";
		pan_right();
		
	  }
	  if(hyp=="UP"){
		 				 
	    stopRecording();
		startRecording();
		pan_up();
		
				 
	  }
	   if(hyp=="DOWN"){
		 				 
	    stopRecording();
		startRecording();
		pan_down();
		stopRecording();
		startRecording();
				} 
	  
	  
	  if(hyp=="ZOOM IN"){
		 				 
	    stopRecording();
		startRecording();
		map.zoomIn();	
				} 
	 
	  
	  if(hyp=="ZOOM OUT"){
		 				 
	    stopRecording();
		startRecording();
		map.zoomOut();	
				} 
	  if(hyp=="LOCATE"){
		 				 
	    stopRecording();
		startRecording();
		locater.locate();	
				} 
				
	if(hyp=="LOCATE STOP"){
		 				 
	    stopRecording();
		startRecording();
		locater.stopLocate();	
				} 
				
	if(hyp=="SHOW INFORMATION"){
		 				 
	    stopRecording();
		startRecording();
		map.revealOSMControl.activate();	
				} 
	
	if(hyp=="HIDE INFORMATION"){
		 				 
	    stopRecording();
		startRecording();
		map.revealOSMControl.deactivate();	
				} 
				
	if(hyp=="MEASUREMENT START"){
		 				 
	    stopRecording();
		startRecording();
		map.measureControl._enable();	
				} 
	
	if(hyp=="MEASUREMENT STOP"){
		 				 
	    stopRecording();
		startRecording();
		map.measureControl._disable();	
				} 
				
	if(hyp=="POINT"){
		 				 
	    stopRecording();
		startRecording();
		L.marker(map.getCenter()).addTo(map);	
				} 
	if(hyp=="MEASUREMENT STOP"){
		 				 
	    stopRecording();
		startRecording();
		map.measureControl._disable();	
				} 
	if(hyp=="LARGE CIRCLE"){
		 				 
	    stopRecording();
		startRecording();
		L.circle(map.getCenter(), 400).addTo(map);	
				} 
	if(hyp=="MEDIUM CIRCLE"){
		 				 
	    stopRecording();
		startRecording();
		L.circle(map.getCenter(), 200).addTo(map);	
				} 
				
	if(hyp=="SMALL CIRCLE"){
		 				 
	    stopRecording();
		startRecording();
		L.circle(map.getCenter(), 100).addTo(map);	
				} 
				
				
		if(hyp=="LARGE RECTANGLE"){
		 				 
	    stopRecording();
		startRecording();
		L.rectangle([[map.getCenter().lat - 0.01, map.getCenter().lng - 0.01],[map.getCenter().lat + 0.01, map.getCenter().lng + 0.01]]).addTo(map);
				} 
	if(hyp=="MEDIUM RECTANGLE"){
		 				 
	    stopRecording();
		startRecording();
		L.rectangle([[map.getCenter().lat - 0.005, map.getCenter().lng - 0.005],[map.getCenter().lat + 0.005, map.getCenter().lng + 0.005]]).addTo(map);	
				} 
				
	if(hyp=="SMALL RECTANGLE"){
		 				 
	    stopRecording();
		startRecording();
		L.rectangle([[map.getCenter().lat - 0.0025, map.getCenter().lng - 0.0025],[map.getCenter().lat + 0.0025, map.getCenter().lng + 0.0025]]).addTo(map);	
				} 
	
   };
	  












	  
	//////////////////////////////////////////////////////////
	/////Functions ///////////////////////////////////////////
	//////////////////////////////////////////////////////////  
	  
	//PAN
	  function pan_left() {
	    
               centerPoint = map.getCenter();
				var m = (map.getBounds().getEast()- map.getBounds().getWest())/4;
                centerPoint.lng -= Math.abs(m);
                $("#command_animation").html("left ").css('fontSize', '13em').animate({
                        'left': '-500px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('left', '45%');
                    });
                map.panTo(centerPoint);
				
				 //outputContainer.innerHTML = "";
				//if (outputContainer) outputContainer.innerHTML = "";
				//document.getElementById("output").innerHTML = "";
	  
	   };
	    function pan_right() {
	  centerPoint = map.getCenter();
				var m = (map.getBounds().getEast()- map.getBounds().getWest())/4;
                centerPoint.lng += Math.abs(m);
                $("#command_animation").html("right").css({
                    'fontSize': '13em'
                }).animate({
                        'left': '100%'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('left', '45%');
                    });
                map.panTo(centerPoint);
	  };
	   function pan_up() {
	  centerPoint = map.getCenter();
				var m = (map.getBounds().getNorth() - map.getBounds().getSouth())/4;
                centerPoint.lat += m;
                $("#command_animation").html("up").css('fontSize', '13em').animate({
                        'top': '-250px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('top', '50%');
                    });
                map.panTo(centerPoint);
	  };
	  
	   function pan_down() {
	  centerPoint = map.getCenter();
				var m = (map.getBounds().getNorth() - map.getBounds().getSouth())/4;
                centerPoint.lat -= m;
                $("#command_animation").html("down").css('fontSize', '13em').animate({
                        'top': '500px'
                    }, 1100,
                    function () {
                        $("#command_animation").html("").css('top', '50%');
                    });
                map.panTo(centerPoint);
	  };  
	  
    </script>
</body>

</html>
